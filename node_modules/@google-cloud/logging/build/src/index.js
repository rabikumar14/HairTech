"use strict";
/*!
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.v2 = exports.protos = exports.Logging = exports.Sink = exports.Severity = exports.Log = exports.Entry = exports.detectServiceContext = exports.middleware = void 0;
const common_1 = require("@google-cloud/common");
const paginator_1 = require("@google-cloud/paginator");
const projectify_1 = require("@google-cloud/projectify");
const promisify_1 = require("@google-cloud/promisify");
const arrify = require("arrify");
const extend = require("extend");
const gax = require("google-gax");
// eslint-disable-next-line @typescript-eslint/no-var-requires
const pumpify = require('pumpify');
const streamEvents = require("stream-events");
const through = require("through2");
const middleware = require("./middleware");
exports.middleware = middleware;
const metadata_1 = require("./metadata");
Object.defineProperty(exports, "detectServiceContext", { enumerable: true, get: function () { return metadata_1.detectServiceContext; } });
const version = require('../../package.json').version;
// eslint-disable-next-line @typescript-eslint/no-var-requires
const v2 = require('./v2');
exports.v2 = v2;
const entry_1 = require("./entry");
Object.defineProperty(exports, "Entry", { enumerable: true, get: function () { return entry_1.Entry; } });
const log_1 = require("./log");
Object.defineProperty(exports, "Log", { enumerable: true, get: function () { return log_1.Log; } });
Object.defineProperty(exports, "Severity", { enumerable: true, get: function () { return log_1.Severity; } });
const sink_1 = require("./sink");
Object.defineProperty(exports, "Sink", { enumerable: true, get: function () { return sink_1.Sink; } });
/**
 * @typedef {object} ClientConfig
 * @property {string} [projectId] The project ID from the Google Developer's
 *     Console, e.g. 'grape-spaceship-123'. We will also check the environment
 *     variable `GCLOUD_PROJECT` for your project ID. If your app is running in
 *     an environment which supports {@link
 * https://cloud.google.com/docs/authentication/production#providing_credentials_to_your_application
 * Application Default Credentials}, your project ID will be detected
 * automatically.
 * @property {string} [keyFilename] Full path to the a .json, .pem, or .p12 key
 *     downloaded from the Google Developers Console. If you provide a path to a
 *     JSON file, the `projectId` option above is not necessary. NOTE: .pem and
 *     .p12 require you to specify the `email` option as well.
 * @property {string} [email] Account email address. Required when using a .pem
 *     or .p12 keyFilename.
 * @property {object} [credentials] Credentials object.
 * @property {string} [credentials.client_email]
 * @property {string} [credentials.private_key]
 * @property {boolean} [autoRetry=true] Automatically retry requests if the
 *     response is related to rate limits or certain intermittent server errors.
 *     We will exponentially backoff subsequent requests by default.
 * @property {number} [maxRetries=3] Maximum number of automatic retries
 *     attempted before returning the error.
 * @property {Constructor} [promise] Custom promise module to use instead of
 *     native Promises.
 */
/**
 * [Stackdriver Logging](https://cloud.google.com/logging/docs) allows you to
 * store, search, analyze, monitor, and alert on log data and events from Google
 * Cloud Platform and Amazon Web Services (AWS).
 *
 * @class
 *
 * @see [What is Stackdriver Logging?](https://cloud.google.com/logging/docs)
 * @see [Introduction to the Stackdriver Logging API](https://cloud.google.com/logging/docs/api)
 * @see [Logging to Stackdriver from Bunyan](https://www.npmjs.com/package/@google-cloud/logging-bunyan)
 * @see [Logging to Stackdriver from Winston](https://www.npmjs.com/package/@google-cloud/logging-winston)
 *
 * @param {ClientConfig} [options] Configuration options.
 *
 * @example <caption>Import the client library</caption>
 * const {Logging} = require('@google-cloud/logging');
 *
 * @example <caption>Create a client that uses <a href="https://cloud.google.com/docs/authentication/production#providing_credentials_to_your_application">Application Default Credentials (ADC)</a>:</caption>
 * const logging = new Logging();
 *
 * @example <caption>Create a client with <a href="https://cloud.google.com/docs/authentication/production#obtaining_and_providing_service_account_credentials_manually">explicitcredentials</a>:</caption>
 * const logging = new Logging({ projectId:
 *  'your-project-id', keyFilename: '/path/to/keyfile.json'
 * });
 *
 * @example <caption>include:samples/quickstart.js</caption>
 * region_tag:logging_quickstart
 * Full quickstart example:
 */
class Logging {
    constructor(options) {
        // Determine what scopes are needed.
        // It is the union of the scopes on all three clients.
        const scopes = [];
        const clientClasses = [
            v2.ConfigServiceV2Client,
            v2.LoggingServiceV2Client,
            v2.MetricsServiceV2Client,
        ];
        for (const clientClass of clientClasses) {
            for (const scope of clientClass.scopes) {
                if (scopes.indexOf(scope) === -1) {
                    scopes.push(scope);
                }
            }
        }
        const options_ = extend({
            libName: 'gccl',
            libVersion: version,
            scopes,
        }, options);
        this.api = {};
        this.auth = new gax.GoogleAuth(options_);
        this.options = options_;
        this.projectId = this.options.projectId || '{{projectId}}';
        this.configService = new v2.ConfigServiceV2Client(this.options);
        this.loggingService = new v2.LoggingServiceV2Client(this.options);
    }
    /**
     * Config to set for the sink. Not all available options are listed here, see
     * the [Sink
     * resource](https://cloud.google.com/logging/docs/reference/v2/rest/v2/projects.sinks#LogSink)
     * definition for full details.
     *
     * @typedef {object} CreateSinkRequest
     * @property {object} [gaxOptions] Request configuration options, outlined
     *     here: https://googleapis.github.io/gax-nodejs/global.html#CallOptions.
     * @property {Bucket|Dataset|Topic} [destination] The destination. The proper ACL
     *     scopes will be granted to the provided destination. Can be one of:
     *     {@link
     * https://cloud.google.com/nodejs/docs/reference/storage/latest/Bucket
     * Bucket},
     *     {@link
     * https://cloud.google.com/nodejs/docs/reference/bigquery/latest/Dataset
     * Dataset}, or {@link
     * https://cloud.google.com/nodejs/docs/reference/pubsub/latest/Topic Topic}
     * @property {string} [filter] An advanced logs filter. Only log entries
     *     matching the filter are written.
     * @property {string} [uniqueWriterIdentity] Determines the kind of IAM
     *     identity returned as `writerIdentity` in the new sink. See {@link https://cloud.google.com/logging/docs/reference/v2/rest/v2/projects.sinks/create#query-parameters}.
     */
    /**
     * @typedef {array} CreateSinkResponse
     * @property {Sink} 0 The new {@link Sink}.
     * @property {object} 1 The full API response.
     */
    /**
     * @callback CreateSinkCallback
     * @param {?Error} err Request error, if any.
     * @param {Sink} sink The new {@link Sink}.
     * @param {object} apiResponse The full API response.
     */
    // jscs:disable maximumLineLength
    /**
     * Create a sink.
     *
     * @see [Sink Overview]{@link https://cloud.google.com/logging/docs/reference/v2/rest/v2/projects.sinks}
     * @see [Advanced Logs Filters]{@link https://cloud.google.com/logging/docs/view/advanced_filters}
     * @see [projects.sinks.create API Documentation]{@link https://cloud.google.com/logging/docs/reference/v2/rest/v2/projects.sinks/create}
     *
     * @param {string} name Name of the sink.
     * @param {CreateSinkRequest} config Config to set for the sink.
     * @param {CreateSinkCallback} [callback] Callback function.
     * @returns {Promise<CreateSinkResponse>}
     * @throws {Error} If a name is not provided.
     * @throws {Error} if a config object is not provided.
     * @see Sink#create
     *
     * @example
     * const {Storage} = require('@google-cloud/storage');
     * const storage = new Storage({
     *   projectId: 'grape-spaceship-123'
     * });
     * const {Logging} = require('@google-cloud/logging');
     * const logging = new Logging();
     *
     * const config = {
     *   destination: storage.bucket('logging-bucket'),
     *   filter: 'severity = ALERT'
     * };
     *
     * function callback(err, sink, apiResponse) {
     *   // `sink` is a Sink object.
     * }
     *
     * logging.createSink('new-sink-name', config, callback);
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * logging.createSink('new-sink-name', config).then(data => {
     *   const sink = data[0];
     *   const apiResponse = data[1];
     * });
     *
     * @example <caption>include:samples/sinks.js</caption>
     * region_tag:logging_create_sink
     * Another example:
     */
    async createSink(name, config) {
        if (typeof name !== 'string') {
            throw new Error('A sink name must be provided.');
        }
        if (typeof config !== 'object') {
            throw new Error('A sink configuration object must be provided.');
        }
        if (common_1.util.isCustomType(config.destination, 'bigquery/dataset')) {
            await this.setAclForDataset_(config);
        }
        if (common_1.util.isCustomType(config.destination, 'pubsub/topic')) {
            await this.setAclForTopic_(config);
        }
        if (common_1.util.isCustomType(config.destination, 'storage/bucket')) {
            await this.setAclForBucket_(config);
        }
        const reqOpts = {
            parent: 'projects/' + this.projectId,
            sink: extend({}, config, { name }),
            uniqueWriterIdentity: config.uniqueWriterIdentity,
        };
        delete reqOpts.sink.gaxOptions;
        delete reqOpts.sink.uniqueWriterIdentity;
        await this.setProjectId(reqOpts);
        const [resp] = await this.configService.createSink(reqOpts, config.gaxOptions);
        const sink = this.sink(resp.name);
        sink.metadata = resp;
        return [sink, resp];
    }
    /**
     * Create an entry object.
     *
     * Using this method will not itself make any API requests. You will use
     * the object returned in other API calls, such as
     * {@link Log#write}.
     *
     * Note, [Cloud Logging Quotas and limits]{@link https://cloud.google.com/logging/quotas}
     * dictates that the maximum log entry size, including all
     * [LogEntry Resource properties]{@link https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry},
     * cannot exceed _approximately_ 256 KB.
     *
     * @see [LogEntry JSON representation]{@link https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry}
     *
     * @param {?object|?string} [resource] See a
     *     [Monitored
     * Resource](https://cloud.google.com/logging/docs/reference/v2/rest/v2/MonitoredResource).
     * @param {object|string} data The data to use as the value for this log
     *     entry.
     * @returns {Entry}
     *
     * @example
     * const {Logging} = require('@google-cloud/logging');
     * const logging = new Logging();
     *
     * const resource = {
     *   type: 'gce_instance',
     *   labels: {
     *     zone: 'global',
     *     instance_id: '3'
     *   }
     * };
     *
     * const entry = logging.entry(resource, {
     *   delegate: 'my_username'
     * });
     *
     * entry.toJSON();
     * // {
     * //   resource: {
     * //     type: 'gce_instance',
     * //     labels: {
     * //       zone: 'global',
     * //       instance_id: '3'
     * //     }
     * //   },
     * //   jsonPayload: {
     * //     delegate: 'my_username'
     * //   }
     * // }
     */
    entry(resource, data) {
        return new entry_1.Entry(resource, data);
    }
    /**
     * Query object for listing entries.
     *
     * @typedef {object} GetEntriesRequest
     * @property {boolean} [autoPaginate=true] Have pagination handled
     *     automatically.
     * @property {string} [filter] An
     *     [advanced logs
     * filter](https://cloud.google.com/logging/docs/view/advanced_filters). An
     * empty filter matches all log entries.
     * @property {object} [gaxOptions] Request configuration options, outlined
     *     here: https://googleapis.github.io/gax-nodejs/global.html#CallOptions.
     * @property {string} [log] A name of the log specifying to pnly return
     *     entries from this log.
     * @property {number} [maxApiCalls] Maximum number of API calls to make.
     * @property {number} [maxResults] Maximum number of items plus prefixes to
     *     return.
     * @property {string} [orderBy] How the results should be sorted,
     *     `timestamp asc` (oldest first) and `timestamp desc` (newest first,
     *     **default**).
     * @property {number} [pageSize] Maximum number of logs to return.
     * @property {string} [pageToken] A previously-returned page token
     *     representing part of the larger set of results to view.
     */
    /**
     * @typedef {array} GetEntriesResponse
     * @property {Entry[]} 0 Array of {@link Entry} instances.
     * @property {object} 1 The full API response.
     */
    /**
     * @callback GetEntriesCallback
     * @param {?Error} err Request error, if any.
     * @param {Entry[]} entries Array of {@link Entry} instances.
     * @param {object} apiResponse The full API response.
     */
    /**
     * List the entries in your logs.
     *
     * @see [entries.list API Documentation]{@link https://cloud.google.com/logging/docs/reference/v2/rest/v2/entries/list}
     *
     * @param {GetEntriesRequest} [query] Query object for listing entries.
     * @param {GetEntriesCallback} [callback] Callback function.
     * @returns {Promise<GetEntriesResponse>}
     *
     * @example
     * const {Logging} = require('@google-cloud/logging');
     * const logging = new Logging();
     *
     * logging.getEntries((err, entries) => {
     *   // `entries` is an array of Stackdriver Logging entry objects.
     *   // See the `data` property to read the data from the entry.
     * });
     *
     * //-
     * // To control how many API requests are made and page through the results
     * // manually, set `autoPaginate` to `false`.
     * //-
     * function callback(err, entries, nextQuery, apiResponse) {
     *   if (nextQuery) {
     *     // More results exist.
     *     logging.getEntries(nextQuery, callback);
     *   }
     * }
     *
     * logging.getEntries({
     *   autoPaginate: false
     * }, callback);
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * logging.getEntries().then(data => {
     *   const entries = data[0];
     * });
     *
     * @example <caption>include:samples/logs.js</caption>
     * region_tag:logging_list_log_entries
     * Another example:
     *
     * @example <caption>include:samples/logs.js</caption>
     * region_tag:logging_list_log_entries_advanced
     * Another example:
     */
    async getEntries(opts) {
        const options = opts ? opts : {};
        // By default, sort entries by descending timestamp
        let reqOpts = extend({ orderBy: 'timestamp desc' }, options);
        // By default, filter entries to last 24 hours only
        const time = new Date();
        time.setDate(time.getDate() - 1);
        const timeFilter = `timestamp >= "${time.toISOString()}"`;
        if (!options.filter) {
            reqOpts = extend({ filter: timeFilter }, reqOpts);
        }
        else if (!options.filter.includes('timestamp')) {
            reqOpts.filter += ` AND ${timeFilter}`;
        }
        reqOpts.resourceNames = arrify(reqOpts.resourceNames);
        this.projectId = await this.auth.getProjectId();
        const resourceName = 'projects/' + this.projectId;
        if (reqOpts.resourceNames.indexOf(resourceName) === -1) {
            reqOpts.resourceNames.push(resourceName);
        }
        delete reqOpts.autoPaginate;
        delete reqOpts.gaxOptions;
        const gaxOptions = extend({
            autoPaginate: options.autoPaginate,
        }, options.gaxOptions);
        const resp = await this.loggingService.listLogEntries(reqOpts, gaxOptions);
        const [entries] = resp;
        if (entries) {
            resp[0] = entries.map(entry_1.Entry.fromApiResponse_);
        }
        return resp;
    }
    /**
     * List the {@link Entry} objects in your logs as a readable object
     * stream.
     *
     * @method Logging#getEntriesStream
     * @param {GetEntriesRequest} [query] Query object for listing entries.
     * @returns {ReadableStream} A readable stream that emits {@link Entry}
     *     instances.
     *
     * @example
     * const {Logging} = require('@google-cloud/logging');
     * const logging = new Logging();
     *
     * logging.getEntriesStream()
     *   .on('error', console.error)
     *   .on('data', entry => {
     *     // `entry` is a Stackdriver Logging entry object.
     *     // See the `data` property to read the data from the entry.
     *   })
     *   .on('end', function() {
     *     // All entries retrieved.
     *   });
     *
     * //-
     * // If you anticipate many results, you can end a stream early to prevent
     * // unnecessary processing and API requests.
     * //-
     * logging.getEntriesStream()
     *   .on('data', function(entry) {
     *     this.end();
     *   });
     */
    getEntriesStream(options = {}) {
        let requestStream;
        const userStream = streamEvents(pumpify.obj());
        userStream.abort = () => {
            if (requestStream) {
                requestStream.abort();
            }
        };
        const toEntryStream = through.obj((entry, _, next) => {
            next(null, entry_1.Entry.fromApiResponse_(entry));
        });
        userStream.once('reading', () => {
            this.auth.getProjectId().then(projectId => {
                this.projectId = projectId;
                if (options.log) {
                    if (options.filter) {
                        options.filter = `(${options.filter}) AND logName="${log_1.Log.formatName_(this.projectId, options.log)}"`;
                    }
                    else {
                        options.filter = `logName="${log_1.Log.formatName_(this.projectId, options.log)}"`;
                    }
                    delete options.log;
                }
                const reqOpts = extend({
                    orderBy: 'timestamp desc',
                }, options);
                reqOpts.resourceNames = arrify(reqOpts.resourceNames);
                reqOpts.resourceNames.push(`projects/${this.projectId}`);
                delete reqOpts.autoPaginate;
                delete reqOpts.gaxOptions;
                const gaxOptions = extend({
                    autoPaginate: options.autoPaginate,
                }, options.gaxOptions);
                let gaxStream;
                requestStream = streamEvents(through.obj());
                requestStream.abort = () => {
                    if (gaxStream && gaxStream.cancel) {
                        gaxStream.cancel();
                    }
                };
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                if (!global.GCLOUD_SANDBOX_ENV) {
                    requestStream.once('reading', () => {
                        try {
                            gaxStream = this.loggingService.listLogEntriesStream(reqOpts, gaxOptions);
                        }
                        catch (error) {
                            requestStream.destroy(error);
                            return;
                        }
                        gaxStream
                            .on('error', err => {
                            requestStream.destroy(err);
                        })
                            .pipe(requestStream);
                        return;
                    });
                }
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                userStream.setPipeline(requestStream, toEntryStream);
            });
        });
        return userStream;
    }
    /**
     * Streaming read of live logs as log entries are ingested. Until the stream
     * is terminated, it will continue reading logs.
     *
     * @method Logging#tailEntries
     * @param {TailEntriesRequest} [query] Query object for tailing entries.
     * @returns {DuplexStream} A duplex stream that emits TailEntriesResponses
     * containing an array of {@link Entry} instances.
     *
     * @example
     * const {Logging} = require('@google-cloud/logging');
     * const logging = new Logging();
     *
     * logging.tailEntries()
     *   .on('error', console.error)
     *   .on('data', resp => {
     *     console.log(resp.entries);
     *     console.log(resp.suppressionInfo);
     *   })
     *   .on('end', function() {
     *     // All entries retrieved.
     *   });
     *
     * //-
     * // If you anticipate many results, you can end a stream early to prevent
     * // unnecessary processing and API requests.
     * //-
     * logging.getEntriesStream()
     *   .on('data', function(entry) {
     *     this.end();
     *   });
     */
    tailEntries(options = {}) {
        const userStream = streamEvents(pumpify.obj());
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        let gaxStream;
        userStream.abort = () => {
            if (gaxStream && gaxStream.cancel) {
                gaxStream.cancel();
            }
        };
        const transformStream = through.obj((data, _, next) => {
            next(null, (() => {
                const formattedEntries = [];
                data.entries.forEach((entry) => {
                    formattedEntries.push(entry_1.Entry.fromApiResponse_(entry));
                });
                const resp = {
                    entries: formattedEntries,
                    suppressionInfo: data.suppressionInfo,
                };
                return resp;
            })());
        });
        this.auth.getProjectId().then(projectId => {
            this.projectId = projectId;
            if (options.log) {
                if (options.filter) {
                    options.filter = `(${options.filter}) AND logName="${log_1.Log.formatName_(this.projectId, options.log)}"`;
                }
                else {
                    options.filter = `logName="${log_1.Log.formatName_(this.projectId, options.log)}"`;
                }
            }
            options.resourceNames = arrify(options.resourceNames);
            options.resourceNames.push(`projects/${this.projectId}`);
            const writeOptions = {
                resourceNames: options.resourceNames,
                ...(options.filter && { filter: options.filter }),
                ...(options.bufferWindow && { bufferwindow: options.bufferWindow }),
            };
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            if (!global.GCLOUD_SANDBOX_ENV) {
                gaxStream = this.loggingService.tailLogEntries(options.gaxOptions);
                // Write can only be called once in a single tail streaming session.
                gaxStream.write(writeOptions);
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                userStream.setPipeline(gaxStream, transformStream);
            }
        });
        return userStream;
    }
    /**
     * Query object for listing entries.
     *
     * @typedef {object} GetLogsRequest
     * @property {boolean} [autoPaginate=true] Have pagination handled
     *     automatically.
     * @property {object} [gaxOptions] Request configuration options, outlined
     *     here: https://googleapis.github.io/gax-nodejs/global.html#CallOptions.
     * @property {number} [maxApiCalls] Maximum number of API calls to make.
     * @property {number} [maxResults] Maximum number of items plus prefixes to
     *     return.
     * @property {number} [pageSize] Maximum number of logs to return.
     * @property {string} [pageToken] A previously-returned page token
     *     representing part of the larger set of results to view.
     */
    /**
     * @typedef {array} GetLogsResponse
     * @property {Log[]} 0 Array of {@link Log} instances.
     * @property {object} 1 The full API response.
     */
    /**
     * @callback GetLogsCallback
     * @param {?Error} err Request error, if any.
     * @param {Log[]} logs Array of {@link Log} instances.
     * @param {object} apiResponse The full API response.
     */
    /**
     * List the entries in your logs.
     *
     * @see [logs.list API Documentation]{@link https://cloud.google.com/logging/docs/reference/v2/rest/v2/logs/list}
     *
     * @param {GetLogsRequest} [query] Query object for listing entries.
     * @param {GetLogsCallback} [callback] Callback function.
     * @returns {Promise<GetLogsResponse>}
     *
     * @example
     * const {Logging} = require('@google-cloud/logging');
     * const logging = new Logging();
     *
     * logging.getLogs((err, logs) => {
     *   // `logs` is an array of Stackdriver Logging log objects.
     * });
     *
     * //-
     * // To control how many API requests are made and page through the results
     * // manually, set `autoPaginate` to `false`.
     * //-
     * function callback(err, entries, nextQuery, apiResponse) {
     *   if (nextQuery) {
     *     // More results exist.
     *     logging.getLogs(nextQuery, callback);
     *   }
     * }
     *
     * logging.getLogs({
     *   autoPaginate: false
     * }, callback);
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * logging.getLogs().then(data => {
     *   const entries = data[0];
     * });
     *
     * @example <caption>include:samples/logs.js</caption>
     * region_tag:logging_list_logs
     * Another example:
     */
    async getLogs(opts) {
        const options = opts ? opts : {};
        this.projectId = await this.auth.getProjectId();
        const reqOpts = extend({}, options, {
            parent: 'projects/' + this.projectId,
        });
        delete reqOpts.autoPaginate;
        delete reqOpts.gaxOptions;
        const gaxOptions = extend({
            autoPaginate: options.autoPaginate,
        }, options.gaxOptions);
        const resp = await this.loggingService.listLogs(reqOpts, gaxOptions);
        const [logs] = resp;
        if (logs) {
            resp[0] = logs.map((logName) => this.log(logName));
        }
        return resp;
    }
    /**
     * List the {@link Log} objects in your project as a readable object stream.
     *
     * @method Logging#getLogsStream
     * @param {GetLogsRequest} [query] Query object for listing entries.
     * @returns {ReadableStream} A readable stream that emits {@link Log}
     *     instances.
     *
     * @example
     * const {Logging} = require('@google-cloud/logging');
     * const logging = new Logging();
     *
     * logging.getLogsStream()
     *   .on('error', console.error)
     *   .on('data', log => {
     *     // `log` is a Stackdriver Logging log object.
     *   })
     *   .on('end', function() {
     *     // All logs retrieved.
     *   });
     *
     * //-
     * // If you anticipate many results, you can end a stream early to prevent
     * // unnecessary processing and API requests.
     * //-
     * logging.getLogsStream()
     *   .on('data', log => {
     *     this.end();
     *   });
     */
    getLogsStream(options = {}) {
        options = options || {};
        let requestStream;
        const userStream = streamEvents(pumpify.obj());
        userStream.abort = () => {
            if (requestStream) {
                requestStream.abort();
            }
        };
        const toLogStream = through.obj((logName, _, next) => {
            next(null, this.log(logName));
        });
        userStream.once('reading', () => {
            this.auth.getProjectId().then(projectId => {
                this.projectId = projectId;
                const reqOpts = extend({}, options, {
                    parent: 'projects/' + this.projectId,
                });
                delete reqOpts.gaxOptions;
                const gaxOptions = extend({
                    autoPaginate: options.autoPaginate,
                }, options.gaxOptions);
                let gaxStream;
                requestStream = streamEvents(through.obj());
                requestStream.abort = () => {
                    if (gaxStream && gaxStream.cancel) {
                        gaxStream.cancel();
                    }
                };
                requestStream.once('reading', () => {
                    try {
                        gaxStream = this.loggingService.listLogsStream(reqOpts, gaxOptions);
                    }
                    catch (error) {
                        requestStream.destroy(error);
                        return;
                    }
                    gaxStream
                        .on('error', err => {
                        requestStream.destroy(err);
                    })
                        .pipe(requestStream);
                    return;
                });
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                userStream.setPipeline(requestStream, toLogStream);
            });
        });
        return userStream;
    }
    /**
     * Query object for listing sinks.
     *
     * @typedef {object} GetSinksRequest
     * @property {boolean} [autoPaginate=true] Have pagination handled
     *     automatically.
     * @property {object} [gaxOptions] Request configuration options, outlined
     *     here: https://googleapis.github.io/gax-nodejs/global.html#CallOptions.
     * @property {number} [maxApiCalls] Maximum number of API calls to make.
     * @property {number} [maxResults] Maximum number of items plus prefixes to
     *     return.
     * @property {number} [pageSize] Maximum number of logs to return.
     * @property {string} [pageToken] A previously-returned page token
     *     representing part of the larger set of results to view.
     */
    /**
     * @typedef {array} GetSinksResponse
     * @property {Sink[]} 0 Array of {@link Sink} instances.
     * @property {object} 1 The full API response.
     */
    /**
     * @callback GetSinksCallback
     * @param {?Error} err Request error, if any.
     * @param {Sink[]} sinks Array of {@link Sink} instances.
     * @param {object} apiResponse The full API response.
     */
    /**
     * Get the sinks associated with this project.
     *
     * @see [projects.sinks.list API Documentation]{@link https://cloud.google.com/logging/docs/reference/v2/rest/v2/projects.sinks/list}
     *
     * @param {GetSinksRequest} [query] Query object for listing sinks.
     * @param {GetSinksCallback} [callback] Callback function.
     * @returns {Promise<GetSinksResponse>}
     *
     * @example
     * const {Logging} = require('@google-cloud/logging');
     * const logging = new Logging();
     *
     * logging.getSinks((err, sinks) => {
     *   // sinks is an array of Sink objects.
     * });
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * logging.getSinks().then(data => {
     *   const sinks = data[0];
     * });
     *
     * @example <caption>include:samples/sinks.js</caption>
     * region_tag:logging_list_sinks
     * Another example:
     */
    async getSinks(opts) {
        const options = opts ? opts : {};
        this.projectId = await this.auth.getProjectId();
        const reqOpts = extend({}, options, {
            parent: 'projects/' + this.projectId,
        });
        delete reqOpts.autoPaginate;
        delete reqOpts.gaxOptions;
        const gaxOptions = extend({
            autoPaginate: options.autoPaginate,
        }, options.gaxOptions);
        const resp = await this.configService.listSinks(reqOpts, gaxOptions);
        const [sinks] = resp;
        if (sinks) {
            resp[0] = sinks.map((sink) => {
                const sinkInstance = this.sink(sink.name);
                sinkInstance.metadata = sink;
                return sinkInstance;
            });
        }
        return resp;
    }
    /**
     * Get the {@link Sink} objects associated with this project as a
     * readable object stream.
     *
     * @method Logging#getSinksStream
     * @param {GetSinksRequest} [query] Query object for listing sinks.
     * @returns {ReadableStream} A readable stream that emits {@link Sink}
     *     instances.
     *
     * @example
     * const {Logging} = require('@google-cloud/logging');
     * const logging = new Logging();
     *
     * logging.getSinksStream()
     *   .on('error', console.error)
     *   .on('data', sink => {
     *     // `sink` is a Sink object.
     *   })
     *   .on('end', function() {
     *     // All sinks retrieved.
     *   });
     *
     * //-
     * // If you anticipate many results, you can end a stream early to prevent
     * // unnecessary processing and API requests.
     * //-
     * logging.getSinksStream()
     *   .on('data', function(sink) {
     *     this.end();
     *   });
     */
    getSinksStream(options) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const self = this;
        options = options || {};
        let requestStream;
        const userStream = streamEvents(pumpify.obj());
        userStream.abort = () => {
            if (requestStream) {
                requestStream.abort();
            }
        };
        const toSinkStream = through.obj((sink, _, next) => {
            const sinkInstance = self.sink(sink.name);
            sinkInstance.metadata = sink;
            next(null, sinkInstance);
        });
        userStream.once('reading', () => {
            this.auth.getProjectId().then(projectId => {
                this.projectId = projectId;
                const reqOpts = extend({}, options, {
                    parent: 'projects/' + self.projectId,
                });
                delete reqOpts.gaxOptions;
                const gaxOptions = extend({
                    autoPaginate: options.autoPaginate,
                }, options.gaxOptions);
                let gaxStream;
                requestStream = streamEvents(through.obj());
                requestStream.abort = () => {
                    if (gaxStream && gaxStream.cancel) {
                        gaxStream.cancel();
                    }
                };
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                if (!global.GCLOUD_SANDBOX_ENV) {
                    requestStream.once('reading', () => {
                        try {
                            gaxStream = this.configService.listSinksStream(reqOpts, gaxOptions);
                        }
                        catch (error) {
                            requestStream.destroy(error);
                            return;
                        }
                        gaxStream
                            .on('error', err => {
                            requestStream.destroy(err);
                        })
                            .pipe(requestStream);
                        return;
                    });
                }
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                userStream.setPipeline(requestStream, toSinkStream);
            });
        });
        return userStream;
    }
    /**
     * Get a reference to a Stackdriver Logging log.
     *
     * @see [Log Overview]{@link https://cloud.google.com/logging/docs/reference/v2/rest/v2/projects.logs}
     *
     * @param {string} name Name of the existing log.
     * @param {object} [options] Configuration object.
     * @param {boolean} [options.removeCircular] Replace circular references in
     *     logged objects with a string value, `[Circular]`. (Default: false)
     * @returns {Log}
     *
     * @example
     * const {Logging} = require('@google-cloud/logging');
     * const logging = new Logging();
     * const log = logging.log('my-log');
     */
    log(name, options) {
        return new log_1.Log(this, name, options);
    }
    /**
     * Get a reference to a Stackdriver Logging sink.
     *
     * @see [Sink Overview]{@link https://cloud.google.com/logging/docs/reference/v2/rest/v2/projects.sinks}
     *
     * @param {string} name Name of the existing sink.
     * @returns {Sink}
     *
     * @example
     * const {Logging} = require('@google-cloud/logging');
     * const logging = new Logging();
     * const sink = logging.sink('my-sink');
     */
    sink(name) {
        return new sink_1.Sink(this, name);
    }
    /**
     * Funnel all API requests through this method, to be sure we have a project
     * ID.
     *
     * @param {object} config Configuration object.
     * @param {object} config.gaxOpts GAX options.
     * @param {function} config.method The gax method to call.
     * @param {object} config.reqOpts Request options.
     * @param {function} [callback] Callback function.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    request(config, callback) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const self = this;
        const isStreamMode = !callback;
        let gaxStream;
        let stream;
        if (isStreamMode) {
            stream = streamEvents(through.obj());
            stream.abort = () => {
                if (gaxStream && gaxStream.cancel) {
                    gaxStream.cancel();
                }
            };
            stream.once('reading', makeRequestStream);
        }
        else {
            makeRequestCallback();
        }
        function prepareGaxRequest(callback) {
            self.auth.getProjectId((err, projectId) => {
                if (err) {
                    callback(err);
                    return;
                }
                self.projectId = projectId;
                let gaxClient = self.api[config.client];
                if (!gaxClient) {
                    // Lazily instantiate client.
                    gaxClient = new v2[config.client](self.options);
                    self.api[config.client] = gaxClient;
                }
                let reqOpts = extend(true, {}, config.reqOpts);
                reqOpts = projectify_1.replaceProjectIdToken(reqOpts, projectId);
                const requestFn = gaxClient[config.method].bind(gaxClient, reqOpts, config.gaxOpts);
                callback(null, requestFn);
            });
        }
        function makeRequestCallback() {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            if (global.GCLOUD_SANDBOX_ENV) {
                return;
            }
            prepareGaxRequest((err, requestFn) => {
                if (err) {
                    callback(err);
                    return;
                }
                requestFn(callback);
            });
        }
        function makeRequestStream() {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            if (global.GCLOUD_SANDBOX_ENV) {
                return through.obj();
            }
            prepareGaxRequest((err, requestFn) => {
                if (err) {
                    stream.destroy(err);
                    return;
                }
                gaxStream = requestFn();
                gaxStream
                    .on('error', err => {
                    stream.destroy(err);
                })
                    .pipe(stream);
            });
            return;
        }
        return stream;
    }
    /**
     * This method is called when creating a sink with a Bucket destination. The
     * bucket must first grant proper ACL access to the Stackdriver Logging
     * account.
     *
     * The parameters are the same as what {@link Logging#createSink} accepts.
     *
     * @private
     */
    async setAclForBucket_(config) {
        const bucket = config.destination;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        await bucket.acl.owners.addGroup('cloud-logs@google.com');
        config.destination = 'storage.googleapis.com/' + bucket.name;
    }
    /**
     * This method is called when creating a sink with a Dataset destination. The
     * dataset must first grant proper ACL access to the Stackdriver Logging
     * account.
     *
     * The parameters are the same as what {@link Logging#createSink} accepts.
     *
     * @private
     */
    async setAclForDataset_(config) {
        const dataset = config.destination;
        const [metadata] = await dataset.getMetadata();
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const access = [].slice.call(arrify(metadata.access));
        access.push({
            role: 'WRITER',
            groupByEmail: 'cloud-logs@google.com',
        });
        await dataset.setMetadata({
            access,
        });
        const baseUrl = 'bigquery.googleapis.com';
        const pId = dataset.parent.projectId;
        const dId = dataset.id;
        config.destination = `${baseUrl}/projects/${pId}/datasets/${dId}`;
    }
    /**
     * This method is called when creating a sink with a Topic destination. The
     * topic must first grant proper ACL access to the Stackdriver Logging
     * account.
     *
     * The parameters are the same as what {@link Logging#createSink} accepts.
     *
     * @private
     */
    async setAclForTopic_(config) {
        const topic = config.destination;
        const [policy] = await topic.iam.getPolicy();
        policy.bindings = arrify(policy.bindings);
        policy.bindings.push({
            role: 'roles/pubsub.publisher',
            members: ['serviceAccount:cloud-logs@system.gserviceaccount.com'],
        });
        await topic.iam.setPolicy(policy);
        const baseUrl = 'pubsub.googleapis.com';
        const topicName = topic.name;
        config.destination = `${baseUrl}/${topicName}`;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async setProjectId(reqOpts) {
        if (this.projectId === '{{projectId}}') {
            this.projectId = await this.auth.getProjectId();
        }
        reqOpts = projectify_1.replaceProjectIdToken(reqOpts, this.projectId);
    }
}
exports.Logging = Logging;
/*! Developer Documentation
 * All async methods (except for streams) will execute a callback in the event
 * that a callback is provided.
 */
promisify_1.callbackifyAll(Logging, {
    exclude: ['request'],
});
/*! Developer Documentation
 *
 * These methods can be auto-paginated.
 */
paginator_1.paginator.extend(Logging, ['getEntries', 'getLogs', 'getSinks']);
/**
 * Reference to the low-level auto-generated clients for the V2 Logging service.
 *
 * @type {object}
 * @property {constructor} LoggingServiceV2Client
 *   Reference to {@link v2.LoggingServiceV2Client}
 * @property {constructor} ConfigServiceV2Client
 *   Reference to {@link v2.ConfigServiceV2Client}
 * @property {constructor} MetricsServiceV2Client
 *   Reference to {@link v2.MetricsServiceV2Client}
 */
module.exports.v2 = v2;
const protos = require("../protos/protos");
exports.protos = protos;
//# sourceMappingURL=index.js.map